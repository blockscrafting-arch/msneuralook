# Deep Code Review & Business Audit

Жёсткий аудит кода editor_bot и смежных модулей. Без церемоний.

---

## 1. Критические уязвимости и баги

### 1.1. `callback.from_user` / `message.from_user` без проверки (review.py)

**Где:** `review.py` строки 144–145, 321, 365.

```python
await add_audit_log(pool, post_id, "approved", actor=str(callback.from_user.id))
await add_audit_log(pool, post_id, "rejected", actor=str(callback.from_user.id))
await add_audit_log(pool, post_id, "edited", actor=str(message.from_user.id))
```

В aiogram у callback/message поле `from_user` может быть `None` (например, при инлайн-режиме или в канале). При `from_user is None` получаем **AttributeError** и падение хендлера. В admin.py везде сделано `actor=str(callback.from_user.id) if callback.from_user else None` — в review этого нет. Это не «редкий кейс», а неконсистентность и потенциальный краш.

**Исправление:** везде в review использовать `actor=str(callback.from_user.id) if callback.from_user else None` (и аналог для message).

---

### 1.2. Lazy-init Lock в publisher.py (тот же косяк, что уже чинили в n8n_receiver)

**Где:** `publisher.py` строки 24–48.

```python
_publish_lock: asyncio.Lock | None = None

def _get_publish_lock() -> asyncio.Lock:
    global _publish_lock
    if _publish_lock is None:
        _publish_lock = asyncio.Lock()
    return _publish_lock
```

В n8n_receiver вы уже убрали lazy-init и создаёте Lock на уровне модуля. Здесь — тот же антипаттерн: теоретическая гонка при первом вызове и лишняя сложность. Либо вы считаете, что в publisher Lock нужен только «внутри цикла», либо это просто забыли привести к одному стилю. В любом случае **дублирование подхода и риск** — один модуль «починен», второй нет.

**Исправление:** сделать как в n8n_receiver: `_publish_lock = asyncio.Lock()` на уровне модуля, везде использовать `_publish_lock`, удалить `_get_publish_lock()`.

---

### 1.3. Нет верхней границы для `post_id` в webhook

**Где:** `n8n_receiver.py` — проверяется только `post_id >= 1`.

`int(raw_post_id)` принимает любое целое. Если n8n или злоумышленник пришлёт `post_id: 2**31` или `999999999999`, вы лезете в БД с огромным id. PostgreSQL и индексы переваривают, но это открывает путь к **переполнению callback_data** в Telegram: `callback_data` ограничен 64 байтами. В кнопках у вас `approve_{post_id}`. При очень большом post_id строка может упереться в лимит — кнопки начнут вести себя непредсказуемо или отвалятся. Плюс логи и audit_log забиваются бессмысленными большими id.

**Исправление:** ограничить, например: `if post_id > 2_000_000_000: return 400` (или разумный верхний предел под вашу схему id).

---

### 1.4. Нет лимита на длину `edited_summary` и `summary` из webhook

**Где:**  
- Webhook: `summary = body.get("summary") or ""` — без ограничения длины.  
- Review: `process_edited_text` — `new_text = message.text or ""` и сразу в `update_post_status(..., edited_summary=new_text)`.

Пользователь или n8n может прислать саммари/редактированный текст в несколько мегабайт. В БД колонка `TEXT` — лимита нет, но вы **расходуете память**, нагружаете БД и при chunked-отправке в Telegram можете упереться в лимиты сообщений. Явного лимита в коде нет — это и уязвимость к DoS, и «говнокод» в смысле отсутствия контракта на вход.

**Исправление:** ввести константу (например, 50_000 символов), обрезать или отклонять слишком длинные `summary` и `new_text` в webhook и в FSM редактирования.

---

## 2. Логические дыры и несогласованность

### 2.1. Двойной `get_post_by_id` в handle_incoming_post

**Где:** `n8n_receiver.py`: сначала `post = await get_post_by_id(pool, post_id)` (строка 375), затем под lock снова `post = await get_post_by_id(pool, post_id)` (строка 380).

Первый вызов используется только для ответа 404. Между двумя вызовами пост могут удалить или изменить — второй вызов под lock всё равно даёт актуальное состояние. Итог: **лишний запрос к БД** на каждый webhook-вызов и размытая ответственность (кто из двух вызовов «источник правды»). Либо убрать первый get и отдавать 404 только после проверки под lock, либо чётко задокументировать, что первый — только для быстрого 404, а решение принимается по второму.

---

### 2.2. Approve разрешает `processing` и `publishing`, но claim — только из `pending_review`

**Где:** `review.py` — допускаются статусы `("pending_review", "publishing", "processing")`, а `claim_pending_for_publish` в БД обновляет только при `status = 'pending_review'`.

Результат: редактор может нажать «Опубликовать» для поста в `processing` или `publishing`, пройти проверку статуса, а потом получить «Пост уже обработан», потому что claim не сработал. С точки зрения целостности данных — ок, с точки зрения UX — путаница: кнопка доступна, но действие не выполняется. Либо не показывать кнопку для `processing`/`publishing`, либо явно обрабатывать этот кейс в тексте ответа («Пост ещё доставляется редакторам, подождите»).

---

### 2.3. Scheduler: N+1 запросов к БД

**Где:** `scheduler.py`: в цикле по `posts_retry` для каждого поста вызывается `get_editors_list(pool)`.

При 25 постах в retry это **25 одинаковых запросов** за один тик. Список редакторов за тик не меняется — достаточно один раз получить и передать в все вызовы `_send_to_editors_background`. Сейчас это просто лишняя нагрузка на БД и «ленивая» реализация.

---

## 3. Безопасность и устойчивость

### 3.1. Нет rate limiting на webhook

Любой, кто знает URL и токен, может слать запросы пачками. Есть только `client_max_size` — от переполнения тела вы защищены, но от **флуда количеством запросов** — нет. Один скрипт может создавать сотни фоновых задач и нагружать БД и бота. Для внутреннего n8n это может быть приемлемо, но контракт «только n8n» нигде не обеспечен технически.

**Рекомендация:** хотя бы простой rate limit по IP или по токену (например, X запросов в минуту) на уровне aiohttp middleware или перед созданием задачи.

---

### 3.2. discussion_client: int(cid), int(mid) без обработки исключений

**Где:** `discussion_client.py`: `return int(cid), int(mid)`.

Если API вернёт `discussion_chat_id`/`discussion_message_id` как float, строку с буквами или null в неожиданном формате, **ValueError** улетит наверх. Вызов из publisher обёрнут в try/except и в итоге вернётся (None, None) по другим ошибкам, но именно здесь падение будет из-за приведения типов. Лучше явно проверять тип и ловить ValueError, возвращая (None, None).

---

### 3.3. Path safety: порядок realpath и проверка под Windows

**Где:** `n8n_receiver._is_pdf_path_safe` и `publisher._is_path_safe`.

Используется `os.path.realpath` и `startswith(base)`. На Windows регистр путей может отличаться, симлинки и разные формы одного пути — тоже. Для Linux в докере текущая логика обычно достаточна, но код не помечен как «только Unix» и при переносе на Windows может дать ложные срабатывания. Минимум — явный комментарий «assumes POSIX path semantics» или единая утилита с тестами под оба окружения.

---

## 4. «Говнокод» и техдолг

### 4.1. Импорт внутри функции в горячем пути

**Где:** `n8n_receiver._send_to_editors_background`: внутри try импортируется `from src.bot.keyboards import review_keyboard`.

Импорт при каждом вызове фоновой задачи — лишняя работа и мусор в коде. То же в `_send_to_one_editor`: `from aiogram.types import FSInputFile`. Импорты должны быть вверху модуля, если только нет циклических зависимостей (здесь их нет).

---

### 4.2. Дублирование проверки пути к PDF

`_is_pdf_path_safe` в n8n_receiver и `_is_path_safe` в publisher по сути делают одно и то же. Два места с одинаковой логикой — при изменении правил (например, для Windows) легко поправить только одно и получить рассинхрон. Имеет смысл вынести в общий util (например, `src.utils.path` или в существующий модуль) и вызывать оттуда.

---

### 4.3. add_audit_log: нет ограничения на длину action и details

В БД `action` — TEXT, `details` — JSONB. В коде никто не ограничивает длину `action` и размер `details`. Теоретически можно писать гигантские строки и объекты (например, из-за бага в коде или при логировании целого исключения). Это засоряет БД и логи. Разумно ввести лимит (например, 200 символов на action, 10 KB на json details) и обрезать или отказывать.

---

### 4.4. Magic numbers и разбросанные константы

Таймауты (90, 180 сек), лимит размера тела (1 MiB), пороги «застрявших» постов (600, 3600 сек), количество ретраев (5, 25) размазаны по разным файлам. Часть вынесена в константы, часть зашита в логике. Для аудита и настройки под разные окружения лучше собрать в одном конфиге (например, в `config.py` или в отдельном модуле констант) с комментариями, что за что отвечает.

---

## 5. Бизнес-логика и данные

### 5.1. Scheduler при падении публикации оставляет статус `scheduled`

**Где:** `scheduler.py`: при исключении в `publish_to_all_channels` пишется audit_log, но статус поста остаётся `scheduled`.

На следующем тике попытка публикации повторяется — это разумно. Но нет ни счётчика попыток, ни перехода в «scheduled_publish_failed» с последующим ручным разбором. При постоянной ошибке (например, неверный канал или токен) один и тот же пост будет бесконечно логировать ошибки раз в 30 секунд. Имеет смысл ввести лимит попыток для scheduled и переводить пост в отдельный статус или помечать в audit_log, чтобы не засорять логи и не скрывать «зависшие» посты.

---

### 5.2. reset_stuck_publishing_posts / reset_send_failed_for_retry: парсинг "UPDATE N"

**Где:** `repository.py`: разбор результата через `result.startswith("UPDATE ")` и `int(result.split()[1])`.

Вы завязываетесь на формат сообщения PostgreSQL. Официально он не гарантирован как стабильный API. На практике он стабилен, но при смене локали или версии теоретически может измениться. Надёжнее использовать `cursor.rowcount` или `RETURNING` и смотреть на количество строк. Сейчас это техдолг и хрупкость.

---

## 6. Итоговая таблица

| Категория        | Критичность | Где                          | Действие |
|------------------|-------------|------------------------------|----------|
| from_user None   | Высокая     | review.py                    | Добавить проверку перед использованием |
| Lazy Lock        | Средняя     | publisher.py                 | Унифицировать с n8n_receiver |
| post_id max      | Средняя     | n8n_receiver handle_incoming_post | Ввести верхнюю границу |
| Длина summary/edit | Средняя   | webhook + review FSM         | Лимит и обрезка/отказ |
| Двойной get_post | Низкая      | n8n_receiver                 | Убрать или явно задокументировать |
| Approve UX       | Низкая      | review.py                    | Уточнить поведение для processing/publishing |
| N+1 editors      | Низкая      | scheduler.py                 | Получить editors один раз за тик |
| Rate limit       | По окружению| webhook                      | Рассмотреть middleware |
| discussion_client int() | Низкая | discussion_client.py   | try/except или валидация типов |
| Импорты в функциях | Низкая    | n8n_receiver                 | Вынести на уровень модуля |
| Дубли path check | Низкая      | n8n_receiver, publisher      | Общий util |
| Длина action/details | Низкая   | add_audit_log                | Лимиты в коде или в БД |
| Парсинг UPDATE N | Низкая      | repository                   | rowcount / RETURNING |

---

Аудит выполнен в режиме «жёсткой проверки». Рекомендуется сначала закрыть пункты с высокой и средней критичностью, затем по возможности разобрать остальные.
