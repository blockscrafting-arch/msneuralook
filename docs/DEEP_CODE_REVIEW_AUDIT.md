# Deep Code Review & Business Audit

Жёсткий аудит по четырём ролям. Сверка с best practices через Context7 (aiohttp, asyncpg, Python security).

---

## Роль 1: Security Auditor

### 1.1 Уязвимость: сравнение Bearer-токена не в constant-time

**Файл:** `editor_bot/src/webhook/n8n_receiver.py`, строки 51–55.

```python
return auth[7:].strip() == expected_token.strip()
```

**Проблема:** Сравнение строк через `==` в Python — не constant-time. Возврат происходит при первом несовпадении символа. По времени ответа можно подбирать токен посимвольно (timing attack). Для коротких секретов разница во времени измерима даже по сети.

**Best practice (Python docs, hmac/secrets):** Использовать `secrets.compare_digest(a, b)` (или `hmac.compare_digest`) для сравнения токенов/секретов.

**Рекомендация:** Заменить на:

```python
import secrets
# ...
return secrets.compare_digest(auth[7:].strip(), expected_token.strip())
```

При пустом `expected_token` сравнение можно не вызывать (оставить ранний return True).

---

### 1.2 Авторизация отключена при пустом токене

**Файл:** `editor_bot/src/webhook/n8n_receiver.py`, строки 49–50.

```python
if not expected_token or not expected_token.strip():
    return True
```

**Проблема:** Если в проде забыли задать `EDITOR_BOT_WEBHOOK_TOKEN`, любой может слать POST на `/incoming/post` и вызывать рассылку редакторам. В документации есть предупреждения, но код не защищает от конфигурационной ошибки.

**Рекомендация:** В production либо требовать непустой токен (и возвращать 503/500, если не задан), либо явно проверять режим (например, переменная `ALLOW_EMPTY_WEBHOOK_TOKEN=false` по умолчанию в проде).

---

### 1.3 n8n: риск SQL-инъекции в Check duplicate

**Файл:** `n8n/workflows/pdf_processing.json`, нода "Check duplicate".

Запрос собирается через подстановку в строку:

- `source_channel`: экранирование через `.replace(/'/g, "''")` и т.д. — типичная ручная защита, но при сложном содержимом (обратные слэши, null, не-UTF-8) возможны краевые случаи и ошибки.
- `source_message_id`: подставляется как `{{ $json.body?.message_id ?? $json.message_id ?? 0 }}` — если из webhook придёт строка или объект, выражение может сгенерировать не число и сломать запрос или логику.

**Рекомендация:** В n8n по возможности использовать параметризованные запросы (если нода Postgres это поддерживает). Иначе явно приводить `message_id` к целому в выражении (например, `Math.floor(Number(...)) || 0`) и ограничить длину/набор символов для `source_channel`.

---

### 1.4 Путь к PDF: path traversal

**Файл:** `editor_bot/src/webhook/n8n_receiver.py`, `_is_pdf_path_safe()`.

Проверка `".." in pdf_path` и `os.path.realpath` — нормальная база. Но если n8n или userbot подставляют путь из сообщения/БД без санитизации, теоретически возможны краевые случаи (разные нормализации, симлинки). Для роли Security — приемлемо, но стоит явно документировать, что `pdf_path` должен формироваться только из доверенного источника (n8n/workflow).

---

## Роль 2: Senior Backend / Code Quality

### 2.1 Fire-and-forget create_task без обработки исключений (aiohttp/Context7)

**Файл:** `editor_bot/src/webhook/n8n_receiver.py`, строки 240–249.

```python
asyncio.create_task(
    _send_to_editors_background(...)
)
return web.json_response(...)
```

**Проблема:** В документации aiohttp явно сказано: *"Avoid using asyncio.create_task() for tasks that must be awaited, as this can hide exceptions and lead to warnings."* Задача не сохраняется и не ожидается. Исключения внутри `_send_to_editors_background` перехватываются в try/except, но если исключение вылетит до входа в этот try (например, при передаче аргументов) или в непокрытом месте — оно уйдёт в event loop и будет залогировано как unhandled, без контекста бизнес-логики.

**Best practice (aiohttp docs):** Долгоживущие фоновые задачи регистрировать через `app.cleanup_ctx` и отменять при shutdown. Либо сохранять ссылку на task и вызывать `task.add_done_callback(...)` для логирования исключений.

**Рекомендация:** Либо сохранять task и добавлять `task.add_done_callback(lambda t: log.error(...) if t.cancelled() or t.exception() else None)`, либо обернуть весь код внутри `_send_to_editors_background` в единый try/except и в except логировать и при необходимости писать в audit_log.

---

### 2.2 aiohttp AppRunner не останавливается при shutdown

**Файл:** `editor_bot/src/main.py`, строки 84–109.

Вызываются `runner.setup()`, `site.start()`, но в `finally` нет `await runner.cleanup()`. Закрываются только `scheduler_task`, `bot.session`, `close_pool`. По документации aiohttp: *"To halt the serving process, the AppRunner.cleanup() method should be invoked."* Без этого при остановке процесса сервер не выполняет корректное завершение (остановка приёма новых соединений, закрытие keep-alive и т.д.).

**Рекомендация:** В `finally` перед/после закрытия пула и бота добавить:

```python
await runner.cleanup()
```

---

### 2.3 Userbot: новая ClientSession на каждый запрос

**Файл:** `userbot/src/services/webhook_sender.py`, строки 56–60.

```python
async with aiohttp.ClientSession() as session:
    async with session.post(...) as resp:
```

Для каждого вызова (включая ретраи) создаётся новая сессия. Это антипаттерн для частых HTTP-запросов: лишние накладные расходы, нет переиспользования соединений (keep-alive). В best practice aiohttp сессию создают один раз и переиспользуют (в рамках приложения или долгоживущей задачи).

**Рекомендация:** Создавать одну сессию на уровень приложения (или на цикл обработки канала) и передавать её в `send_to_n8n_webhook` или хранить в замыкании/объекте сервиса. Закрывать сессию при остановке приложения.

---

### 2.4 Глобальный lock с ленивой инициализацией

**Файл:** `editor_bot/src/webhook/n8n_receiver.py`, `_webhook_lock`, `_get_webhook_lock()`.

Инициализация в event loop — ок. Но глобальная переменная и функция без явной документации о потокобезопасности и о том, что lock один на всё приложение. При росте числа воркеров/процессов один lock на процесс — нормально; если когда-нибудь будет несколько app-инстансов за одним пулом, поведение нужно явно описать.

Замечание не критичное, но для "code quality" лучше вынести lock в состояние приложения (например, `app["webhook_lock"]`) при создании приложения, чтобы не полагаться на глобал.

---

## Роль 3: DevOps / Reliability

### 3.1 Нет graceful shutdown для aiohttp (уже в роли 2)

Отсутствие `runner.cleanup()` — это и проблема надёжности: при рестарте контейнера или деплое активные запросы к webhook обрываются без корректного завершения. Упоминается в роли 2; здесь фиксируем как риск для деплоев и рестартов.

---

### 3.2 Фоновая задача переживает процесс

После `return web.json_response(...)` запрос с точки зрения n8n завершён. Фоновая задача продолжает работать в том же процессе. При `docker stop` или kill процесс может быть убит до завершения рассылки редакторам. Пост в БД останется в `processing`, редакторы не получат уведомление, n8n считает вызов успешным.

**Рекомендация:** Либо принять как осознанный компромисс (и описать в документации), либо добавить механизм "восстановления" постов в статусе `processing` без `editor_message_id` (например, периодическая задача или ручной скрипт), либо уменьшить вероятность обрыва (короткий shutdown timeout, предупреждение в DEPLOY о graceful stop).

---

### 3.3 n8n Merge: режим combine без указания "by position"

**Файл:** `n8n/workflows/pdf_processing.json`, нода Merge: `"parameters":{"mode":"combine","options":{}}`, typeVersion 2.1.

В документации n8n для Merge в режиме "combine" есть подрежимы: by position, by fields, by all combinations. В JSON не указано `mergeByFields` и не указано явно "by position". В зависимости от версии ноды поведение по умолчанию может быть разным. Если объединение идёт не по позиции, пары (Webhook item, Check duplicate item) могут быть неверными и ветка "новый пост" получит не те данные.

**Рекомендация:** В UI n8n проверить, что для Merge выбран "Combine by position". При экспорте workflow убедиться, что в JSON это отражено (при необходимости поправить параметры ноды вручную или переэкспортировать).

---

## Роль 4: Business Logic / Product

### 4.1 504 как успех: риск потери факта доставки

**Файл:** `userbot/src/services/webhook_sender.py`, строки 72–79.

При ответе 504 возвращается `True` ("принято"). n8n при этом может ещё обрабатывать запрос и в итоге либо успешно вызвать editor-bot, либо упасть по таймауту. Userbot не различает эти случаи и не ретраит. С точки зрения бизнеса: часть постов при нестабильной сети или перегрузке n8n может "потеряться" (ни 200, ни явная ошибка у userbot, пост не попал в n8n или не дошёл до редакторов).

**Рекомендация:** Либо оставить текущее поведение как компромисс (снижение дублей ценой возможной потери части запросов при 504), но явно описать это в PRODUCT/DEPLOY и рассмотреть мониторинг "постов без ответа n8n". Либо ввести один осторожный ретрай на 504 с большой паузой (например, 60 s), чтобы уменьшить и дубли, и потери.

---

### 4.2 Ранняя идемпотентность: гонка двух запросов

**Сценарий:** Userbot шлёт первый POST, n8n начинает выполнение. Через 1 s userbot ретраит (например, из-за старого кода или другой ошибки). Второй запрос приходит в n8n. Оба проходят Check duplicate до того, как первый запрос вставит запись в Postgres (INSERT идёт позже в цепочке). Оба получат `is_duplicate = false` и пойдут в ветку "новый пост". Получатся два прогона PDF/OpenAI и два вызова Notify Editor Bot. Editor-bot отсечёт дубли по post_id, но нагрузка и дублирование работы остаются.

**Вывод:** Ранняя проверка уменьшает дубли при "типичных" ретраях (когда первый запрос уже успел записать в БД), но не убирает гонку при двух одновременных или почти одновременных запросах. Это стоит описать в документации как ограничение.

---

### 4.3 Статус "approved" в схеме БД vs код

**Файл:** `init_db/init.sql`: в CHECK для `posts.status` есть значение `'approved'`. В коде (repository, review handlers) используются `pending_review`, `published`, `rejected`, `scheduled` и т.д. Статус `approved` в коде не выставляется (в audit_log пишется action `"approved"`, но не статус поста). Несоответствие схемы и кода может путать при доработках и миграциях.

**Рекомендация:** Либо убрать `approved` из CHECK, если он не используется как статус поста, либо ввести его в логику (например, временный статус между "одобрено редактором" и "опубликовано") и явно описать в документации.

---

## Сводная таблица

| # | Роль | Критичность | Проблема |
|---|------|--------------|----------|
| 1.1 | Security | Средняя | Сравнение токена не constant-time (timing attack) |
| 1.2 | Security | Средняя | Пустой webhook token отключает авторизацию |
| 1.3 | Security | Низкая | n8n Check duplicate: ручная подстановка в SQL, краевые случаи |
| 2.1 | Backend | Средняя | create_task без ссылки/done_callback, скрытые исключения |
| 2.2 | Backend | Высокая | Нет runner.cleanup() при shutdown |
| 2.3 | Backend | Низкая | Userbot: новая ClientSession на каждый запрос |
| 2.4 | Backend | Низкая | Глобальный webhook lock, лучше app state |
| 3.1 | DevOps | Высокая | Тот же runner.cleanup() |
| 3.2 | DevOps | Средняя | Фоновая рассылка может не успеть при остановке процесса |
| 3.3 | DevOps | Средняя | Merge node: режим combine без явного "by position" |
| 4.1 | Business | Средняя | 504 = success: риск потери поста при сбоях |
| 4.2 | Business | Низкая | Гонка двух запросов при ранней идемпотентности |
| 4.3 | Business | Низкая | Статус "approved" в схеме не используется в коде |

---

## Приоритеты исправлений

1. **Обязательно:** `runner.cleanup()` в `main.py` в блоке `finally`.
2. **Настоятельно:** Сравнение токена через `secrets.compare_digest`.
3. **Желательно:** Обработка исключений у фоновой задачи (done_callback или единый try/except с логированием); проверка/документирование Merge "by position"; описание риска 504 и статуса "approved" в документации.
4. **По возможности:** Переиспользование aiohttp ClientSession в userbot; вынос webhook lock в app state.
